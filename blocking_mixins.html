<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>panda.blocking_mixins API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>panda.blocking_mixins</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># XXX: Do not call any of the following from the main thread- they depend on the CPU loop running
from .decorators import blocking
from .utils import progress, make_iso, debug
from shlex import quote as shlex_quote
from os import path

class blocking_mixins():
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False):
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999)
        else:
            result = self.serial_console.expect()
        return result

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)
        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None):
        if not iso_name: iso_name = copy_directory + &#39;.iso&#39;
        progress(&#34;Creating ISO {}...&#34;.format(iso_name))

        make_iso(copy_directory, iso_name)

        copy_directory = path.split(copy_directory)[-1] # Get dirname

        # 1) we insert the CD drive TODO: the cd-drive name should be a config option, see the values in qcow.py
        self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))

        # 2) run setup script
        # setup_sh: 
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        setup_sh = &#34;mkdir -p {mount_dir}; while ! mount /dev/cdrom {mount_dir}; do sleep 0.3; &#34; \
               &#34; umount /dev/cdrom; done; {mount_dir}/setup.sh &amp;&gt; /dev/null || true &#34; \
               .format(mount_dir = (shlex_quote(copy_directory)))
        progress(&#34;setup_sh = [%s] &#34; % setup_sh)
        progress(self.run_serial_cmd(setup_sh))

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def check_crashed(self):
        &#39;&#39;&#39;
        After end_analysis, check if an exn was caught in a callback.
        If so, print traceback and kill this python instance
        TODO: currently prints 2 stack frames too low (shows pypanda internals), should hide those
        &#39;&#39;&#39;
        if self.exception is not None:
            import traceback, os
            try:
                raise self.exception
            except:
                traceback.print_exc()
            os._exit(1) # Force process to exit now

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="panda.blocking_mixins.blocking_mixins"><code class="flex name class">
<span>class <span class="ident">blocking_mixins</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class blocking_mixins():
    @blocking
    def stop_run(self):
        &#39;&#39;&#39;
        From a blocking thread, request vl.c loop to break. Returns control flow in main thread.
        In other words, once this is called, panda.run() will finish and your main thread will continue.
        If you also want to unload plugins, use end_analysis instead

        XXX: This doesn&#39;t work in replay mode
        &#39;&#39;&#39;
        self.libpanda.panda_break_vl_loop_req = True

    @blocking
    def run_serial_cmd(self, cmd, no_timeout=False):
        self.running.wait() # Can only run serial when guest is running
        self.serial_console.sendline(cmd.encode(&#34;utf8&#34;))
        if no_timeout:
            result = self.serial_console.expect(timeout=9999)
        else:
            result = self.serial_console.expect()
        return result

    @blocking
    def type_serial_cmd(self, cmd):
        #Can send message into socket without guest running (no self.running.wait())
        self.serial_console.send(cmd.encode(&#34;utf8&#34;)) # send, not sendline

    def finish_serial_cmd(self):
        result = self.serial_console.send_eol()
        result = self.serial_console.expect()
        return result

    @blocking
    def run_monitor_cmd(self, cmd):
        self.monitor_console.sendline(cmd.encode(&#34;utf8&#34;))
        result = self.monitor_console.expect()
        return result

    @blocking
    def revert_sync(self, snapshot_name):
        result = self.run_monitor_cmd(&#34;loadvm {}&#34;.format(snapshot_name))
        if result.startswith(&#34;Length mismatch&#34;):
            raise RuntimeError(&#34;QEMU machine&#39;s RAM size doesn&#39;t match snapshot RAM size!&#34;)
        return result

    @blocking
    def delvm_sync(self, snapshot_name):
        self.run_monitor_cmd(&#34;delvm {}&#34;.format(snapshot_name))

    @blocking
    def copy_to_guest(self, copy_directory, iso_name=None):
        if not iso_name: iso_name = copy_directory + &#39;.iso&#39;
        progress(&#34;Creating ISO {}...&#34;.format(iso_name))

        make_iso(copy_directory, iso_name)

        copy_directory = path.split(copy_directory)[-1] # Get dirname

        # 1) we insert the CD drive TODO: the cd-drive name should be a config option, see the values in qcow.py
        self.run_monitor_cmd(&#34;change ide1-cd0 \&#34;{}\&#34;&#34;.format(iso_name))

        # 2) run setup script
        # setup_sh: 
        #   Make sure cdrom didn&#39;t automount
        #   Make sure guest path mirrors host path
        #   if there is a setup.sh script in the directory,
        #   then run that setup.sh script first (good for scripts that need to
        #   prep guest environment before script runs)
        setup_sh = &#34;mkdir -p {mount_dir}; while ! mount /dev/cdrom {mount_dir}; do sleep 0.3; &#34; \
               &#34; umount /dev/cdrom; done; {mount_dir}/setup.sh &amp;&gt; /dev/null || true &#34; \
               .format(mount_dir = (shlex_quote(copy_directory)))
        progress(&#34;setup_sh = [%s] &#34; % setup_sh)
        progress(self.run_serial_cmd(setup_sh))

    @blocking
    def record_cmd(self, guest_command, copy_directory=None, iso_name=None, setup_command=None, recording_name=&#34;recording&#34;, snap_name=&#34;root&#34;, ignore_errors=False):
        &#39;&#39;&#39;
        Take a recording as follows:
            0) Revert to the specified snapshot name if one is set. By default &#39;root&#39;. Set to `None` if you have already set up the guest and are ready to record with no revert
            1) Create an ISO of files that need to be copied into the guest if copy_directory is specified. Copy them in
            2) Run the setup_command in the guest, if provided
            3) Type the command you wish to record but do not press enter to begin execution. This avoids the recording capturing the command being typed
            4) Begin the recording (name controlled by recording_name)
            5) Press enter in the guest to begin the command. Wait until it finishes.
            6) End the recording
        &#39;&#39;&#39;
        # 0) Revert to the specified snapshot
        if snap_name is not None:
            self.revert_sync(snap_name) # Can&#39;t use self.revert because that would would run async and we&#39;d keep going before the revert happens

        # 1) Make copy_directory into an iso and copy it into the guest - It will end up at the exact same path
        if copy_directory: # If there&#39;s a directory, build an ISO and put it in the cddrive
            # Make iso
            self.copy_to_guest(copy_directory, iso_name)

        # 2) Run setup_command, if provided before we start the recording (good place to CD or install, etc)
        if setup_command:
            print(f&#34;Running setup command {setup_command}&#34;)
            r = self.run_serial_cmd(setup_command)
            print(f&#34;Setup command results: {r}&#34;)

        # 3) type commmand (note we type command, start recording, finish command)
        self.type_serial_cmd(guest_command)

        # 4) start recording
        self.run_monitor_cmd(&#34;begin_record {}&#34;.format(recording_name))

        # 5) finish command
        result = self.finish_serial_cmd()

        if debug:
            progress(&#34;Result of `{}`:&#34;.format(guest_command))
            print(&#34;\t&#34;+&#34;\n\t&#34;.join(result.split(&#34;\n&#34;))+&#34;\n&#34;)

        if &#34;No such file or directory&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Command not found while taking recording&#34;)

        if &#34;cannot execute binary file&#34; in result and not ignore_errors:
            print(&#34;Bad output running command: {}&#34;.format(result))
            raise RuntimeError(&#34;Could not execute binary while taking recording&#34;)

        # 6) End recording
        self.run_monitor_cmd(&#34;end_record&#34;)

        print(&#34;Finished recording&#34;)

    @blocking
    def check_crashed(self):
        &#39;&#39;&#39;
        After end_analysis, check if an exn was caught in a callback.
        If so, print traceback and kill this python instance
        TODO: currently prints 2 stack frames too low (shows pypanda internals), should hide those
        &#39;&#39;&#39;
        if self.exception is not None:
            import traceback, os
            try:
                raise self.exception
            except:
                traceback.print_exc()
            os._exit(1) # Force process to exit now

    @blocking
    def interact(self, confirm_quit=True):
        &#39;&#39;&#39;
        Expose console interactively until user types pandaquit
        Must be run in blocking thread.

        TODO: This should probably repace self.serial_console with something
        that directly renders output to the user. Then we don&#39;t have to handle
        buffering and other problems. But we will need to re-enable the serial_console
        interface after this returns
        &#39;&#39;&#39;
        print(&#34;PANDA: entering interactive mode. Type pandaquit to exit&#34;)
        prompt = self.expect_prompt.decode(&#34;utf8&#34;) if self.expect_prompt  else &#34;$ &#34;
        if not prompt.endswith(&#34; &#34;): prompt += &#34; &#34;
        while True:
            cmd = input(prompt) # TODO: Strip all control characters - Ctrl-L breaks things
            if cmd.strip() == &#39;pandaquit&#39;:
                if confirm_quit:
                    q = input(&#34;PANDA: Quitting interactive mode. Are you sure? (y/n) &#34;)
                    if len(q) and q.lower()[0] == &#39;y&#39;:
                        break
                    else:
                        continue
                else: # No confirm - just break
                    break
            r = self.run_serial_cmd(cmd) # XXX: may timeout
            print(r)

    @blocking
    def do_panda_finish(self):
        &#39;&#39;&#39;
        Call panda_finish. Note this isn&#39;t really blocking - the
        guest should have exited by now, but queue this after
        (blocking) shutdown commands in our internal async queue
        so it must also be labeled as blocking.
        &#39;&#39;&#39;
#        assert (not self.running.is_set()), &#34;Can&#39;t finish while still running&#34;
        self.panda_finish()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="panda.main.Panda" href="main.html#panda.main.Panda">Panda</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="panda.blocking_mixins.blocking_mixins.check_crashed"><code class="name flex">
<span>def <span class="ident">check_crashed</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.copy_to_guest"><code class="name flex">
<span>def <span class="ident">copy_to_guest</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.delvm_sync"><code class="name flex">
<span>def <span class="ident">delvm_sync</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.do_panda_finish"><code class="name flex">
<span>def <span class="ident">do_panda_finish</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.finish_serial_cmd"><code class="name flex">
<span>def <span class="ident">finish_serial_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_serial_cmd(self):
    result = self.serial_console.send_eol()
    result = self.serial_console.expect()
    return result</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.record_cmd"><code class="name flex">
<span>def <span class="ident">record_cmd</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.revert_sync"><code class="name flex">
<span>def <span class="ident">revert_sync</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.run_monitor_cmd"><code class="name flex">
<span>def <span class="ident">run_monitor_cmd</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.run_serial_cmd"><code class="name flex">
<span>def <span class="ident">run_serial_cmd</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.stop_run"><code class="name flex">
<span>def <span class="ident">stop_run</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="panda.blocking_mixins.blocking_mixins.type_serial_cmd"><code class="name flex">
<span>def <span class="ident">type_serial_cmd</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    assert (threading.current_thread() is not threading.main_thread()), &#34;Blocking function run in main thread&#34;
    return func(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="panda" href="index.html">panda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="panda.blocking_mixins.blocking_mixins" href="#panda.blocking_mixins.blocking_mixins">blocking_mixins</a></code></h4>
<ul class="two-column">
<li><code><a title="panda.blocking_mixins.blocking_mixins.check_crashed" href="#panda.blocking_mixins.blocking_mixins.check_crashed">check_crashed</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.copy_to_guest" href="#panda.blocking_mixins.blocking_mixins.copy_to_guest">copy_to_guest</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.delvm_sync" href="#panda.blocking_mixins.blocking_mixins.delvm_sync">delvm_sync</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.do_panda_finish" href="#panda.blocking_mixins.blocking_mixins.do_panda_finish">do_panda_finish</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.finish_serial_cmd" href="#panda.blocking_mixins.blocking_mixins.finish_serial_cmd">finish_serial_cmd</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.interact" href="#panda.blocking_mixins.blocking_mixins.interact">interact</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.record_cmd" href="#panda.blocking_mixins.blocking_mixins.record_cmd">record_cmd</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.revert_sync" href="#panda.blocking_mixins.blocking_mixins.revert_sync">revert_sync</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.run_monitor_cmd" href="#panda.blocking_mixins.blocking_mixins.run_monitor_cmd">run_monitor_cmd</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.run_serial_cmd" href="#panda.blocking_mixins.blocking_mixins.run_serial_cmd">run_serial_cmd</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.stop_run" href="#panda.blocking_mixins.blocking_mixins.stop_run">stop_run</a></code></li>
<li><code><a title="panda.blocking_mixins.blocking_mixins.type_serial_cmd" href="#panda.blocking_mixins.blocking_mixins.type_serial_cmd">type_serial_cmd</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>